import: ../functions/aastep.yaml
styles:
    functions-aastep:
        doc:
            author:
                name: Matt DesLauriers
                twitter: mattdesl
            description: 'AnitAliased ```step()``` function implemented by [Matt DesLauriers](https://twitter.com/mattdesl)
                in this module <https://github.com/stackgl/glsl-aastep>

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "// AntiAliased Step function\n//=============================\n\
                    float aastep(float threshold, float value) {\n    #ifdef TANGRAM_FRAGMENT_SHADER\n\
                    \        #ifdef TANGRAM_EXTENSION_OES_standard_derivatives\n \
                    \           float afwidth = length(vec2(dFdx(value), dFdy(value)))\
                    \ * 0.70710678118654757;\n            return smoothstep(threshold-afwidth,\
                    \ threshold+afwidth, value);\n        #else\n            return\
                    \ step(threshold, value);\n        #endif  \n    #else\n     \
                    \   return step(threshold, value);\n    #endif\n}"
            extensions: OES_standard_derivatives
    functions-easing:
        doc:
            author:
                name: StackGL
                url: http://stack.gl/
            description: 'Easing functions originally develop by Robert Penner''s
                and transformed to GLSL by [StackGL](http://stack.gl/) in this repo:
                <https://github.com/stackgl/glsl-easings>

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "float linear (in float t) {\n    return t;\n}\n\nfloat exponentialIn\
                    \ (in float t) {\n    return t == 0.0 ? t : pow(2.0, 10.0 * (t\
                    \ - 1.0));\n}\n\nfloat exponentialOut (in float t) {\n    return\
                    \ t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialInOut\
                    \ (in float t) {\n    return t == 0.0 || t == 1.0\n    ? t\n \
                    \   : t < 0.5\n        ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\
                    \        : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat\
                    \ sineIn (in float t) {\n    return sin((t - 1.0) * HALF_PI) +\
                    \ 1.0;\n}\n\nfloat sineOut (in float t) {\n    return sin(t *\
                    \ HALF_PI);\n}\n\nfloat sineInOut (in float t) {\n    return -0.5\
                    \ * (cos(PI * t) - 1.0);\n}\n\nfloat qinticIn (in float t) {\n\
                    \    return pow(t, 5.0);\n}\n\nfloat qinticOut (in float t) {\n\
                    \    return 1.0 - (pow(t - 1.0, 5.0));\n}\n\nfloat qinticInOut\
                    \ (in float t) {\n    return t < 0.5\n        ? +16.0 * pow(t,\
                    \ 5.0)\n        : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\n\
                    float quarticIn (in float t) {\n    return pow(t, 4.0);\n}\n\n\
                    float quarticOut (in float t) {\n    return pow(t - 1.0, 3.0)\
                    \ * (1.0 - t) + 1.0;\n}\n\nfloat quarticInOut (in float t) {\n\
                    \    return t < 0.5\n        ? +8.0 * pow(t, 4.0)\n        : -8.0\
                    \ * pow(t - 1.0, 4.0) + 1.0;\n}\n\nfloat quadraticInOut (in float\
                    \ t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p\
                    \ + (4.0 * t) - 1.0;\n}\n\nfloat quadraticIn (in float t) {\n\
                    \    return t * t;\n}\n\nfloat quadraticOut (in float t) {\n \
                    \   return -t * (t - 2.0);\n}\n\nfloat cubicIn (in float t) {\n\
                    \    return t * t * t;\n}\n\nfloat cubicOut (in float t) {\n \
                    \   float f = t - 1.0;\n    return f * f * f + 1.0;\n}\n\nfloat\
                    \ cubicInOut (in float t) {\n    return t < 0.5\n        ? 4.0\
                    \ * t * t * t\n        : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n\
                    }\n\nfloat elasticIn (in float t) {\n    return sin(13.0 * t *\
                    \ HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat elasticOut\
                    \ (in float t) {\n    return sin(-13.0 * (t + 1.0) * HALF_PI)\
                    \ * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat elasticInOut (in float\
                    \ t) {\n    return t < 0.5\n        ? 0.5 * sin(+13.0 * HALF_PI\
                    \ * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5\
                    \ * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0,\
                    \ -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nfloat circularIn (in float\
                    \ t) {\n    return 1.0 - sqrt(1.0 - t * t);\n}\n\nfloat circularOut\
                    \ (in float t) {\n    return sqrt((2.0 - t) * t);\n}\n\nfloat\
                    \ circularInOut (in float t) {\n    return t < 0.5\n        ?\
                    \ 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n        : 0.5 * (sqrt((3.0\
                    \ - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat bounceOut\
                    \ (in float t) {\n    const float a = 4.0 / 11.0;\n    const float\
                    \ b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const\
                    \ float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n\
                    \    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t *\
                    \ t;\n\n    return t < a\n    ? 7.5625 * t2\n    : t < b\n   \
                    \     ? 9.075 * t2 - 9.9 * t + 3.4\n        : t < c\n        \
                    \    ? ca * t2 - cb * t + cc\n            : 10.8 * t * t - 20.52\
                    \ * t + 10.72;\n}\n\nfloat bounceIn (in float t) {\n    return\
                    \ 1.0 - bounceOut(1.0 - t);\n}\n\nfloat bounceInOut (in float\
                    \ t) {\n    return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 -\
                    \ t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n\
                    float backIn (in float t) {\n    return pow(t, 3.0) - t * sin(t\
                    \ * PI);\n}\n\nfloat backOut (in float t) {\n    float f = 1.0\
                    \ - t;\n    return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\
                    \nfloat backInOut (in float t) {\n    float f = t < 0.5\n    ?\
                    \ 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n    float g = pow(f,\
                    \ 3.0) - f * sin(f * PI);\n\n    return t < 0.5\n    ? 0.5 * g\n\
                    \    : 0.5 * (1.0 - g) + 0.5;\n}"
            defines:
                HALF_PI: 1.5707963267948966
                PI: 3.141592653589793
    patterns-dots:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: "Collection of functions to draw dot patterns that animate\
                \ between zoom levels. To learn more about patterns check [this chapter\
                \ from the Book of Shaders](https://thebookofshaders.com/09/)    \n"
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        mix:
        - space-tile
        - tiling-brick
        - shapes-circle
        - functions-easing
        shaders:
            blocks:
                global: "// Interpolated dot patern between zooms attached to tile\
                    \ coords\nfloat TileDots(float scale, float size) {\n    // Beginning\
                    \ of the transition\n    vec2 IN = brick(getTileCoords()*scale,2.);\n\
                    \    float A = circleDF(vec2(0.5)-IN)*1.8;\n    //\n    // If\
                    \ over 18. add an end B to transition with\n    float d = 0.0;\n\
                    \    if (u_map_position.z < 18.) {\n        vec2 OUT = fract(getTileCoords()*scale*2.);\n\
                    \        float B = circleDF(vec2(0.25)-OUT)*5.;\n        B = min(B,\
                    \ circleDF(vec2(0.75,0.25)-OUT)*5.);\n        B = min(B, circleDF(vec2(0.5,0.75)-OUT)*5.);\n\
                    \        B = min(B, circleDF(vec2(0.,0.75)-OUT)*5.);\n       \
                    \ B = min(B, circleDF(vec2(1.,0.75)-OUT)*5.);\n        d = mix(A,\
                    \ B, linear(fract(u_map_position.z)));\n    } else {\n       \
                    \ d = A;\n    }\n    //\n    // Use the antialias step to make\
                    \ a shape from the DF\n    return aastep(size,d);;\n}"
            defines:
                DOTS_FNC: linear
    polygons-dots:
        base: polygons
        mix:
        - patterns-dots
        shaders:
            blocks:
                color: color.rgb = mix(color.rgb, DOTS_COLOR, TileDots(DOTS_SCALE,
                    DOTS_SIZE));
            defines:
                DOTS_COLOR: color.rgb*.5
                DOTS_SCALE: 10.0
                DOTS_SIZE: 0.41
    shapes-circle:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: 'Collection of functions to draw circles. To learn more about
                how to make shapes on shaders go to From check [this chapter about
                shapes from the Book of Shaders](https://thebookofshaders.com/07/)

                '
            examples:
                lego:
                    img: https://tangrams.github.io/tangram-sandbox/styles/lego.png
                    lines: 109-110
                    url: https://tangrams.github.io/tangram-sandbox/styles/lego.yaml
                nursery:
                    img: https://tangrams.github.io/tangram-sandbox/styles/nursery.png
                    lines: 146
                    url: https://tangrams.github.io/tangram-sandbox/styles/nursery.yaml
                patterns:
                    img: https://tangrams.github.io/tangram-sandbox/styles/patterns.png
                    lines: 146
                    url: https://tangrams.github.io/tangram-sandbox/styles/patterns.yaml
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        mix: functions-aastep
        shaders:
            blocks:
                global: "// get distance field of a Circle\n// ================================\n\
                    float circleDF (vec2 st) {\n    return dot(st,st);\n}\n//\n//\
                    \ Draw a circle in the middle of the ST space\n// ================================\n\
                    float circle (vec2 st, float radius) {\n    return 1.-aastep(radius,\
                    \ circleDF(st-vec2(0.5))*PI);\n}"
            defines:
                PI: 3.141592653589793
    space-tile:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: 'Get the position on the tile

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "// Variant to be add to both vertex and fragments shaders\n\
                    varying vec3 v_pos;\n//\n// Get the coordinates in tile space\n\
                    // ================================\nvec2 getTileCoords() {\n\
                    \    return fract(v_pos.xy);\n}\n"
                position: '// Normalize the attribute position of a vertex

                    v_pos = modelPosition().xyz;'
    tiling-brick:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: 'Repeats a coordinate space (`vec2 st`) in diferent brick-like
                tiles N times (`float zoom`). For more information about tilling patterns
                read [this chapter of The Book of Shaders](https://thebookofshaders.com/09/)

                '
            examples:
                nursery:
                    img: https://tangrams.github.io/tangram-sandbox/styles/nursery.png
                    lines: 99
                    url: https://tangrams.github.io/tangram-sandbox/styles/nursery.yaml
                patterns:
                    img: https://tangrams.github.io/tangram-sandbox/styles/patterns.png
                    lines: 130
                    url: https://tangrams.github.io/tangram-sandbox/styles/patterns.yaml
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "vec2 brick (vec2 st, float zoom) {\n    st *= zoom;\n   \
                    \ // Here is where the offset is happening\n    st.x += step(1.,\
                    \ mod(st.y,2.0)) * 0.5;\n    return fract(st);\n}"
