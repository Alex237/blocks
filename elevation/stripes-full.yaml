import:
- ../functions/aastep.yaml
- ../geometry/matrices.yaml
sources:
    normals-elevation:
        max_zoom: 15
        type: Raster
        url: https://s3.amazonaws.com/elevation-tiles-prod/normal/{z}/{x}/{y}.png
styles:
    elevation-stripes:
        base: polygons
        blend: inlay
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: 'Perfect for the `landuse` layer on your elevation maps,
                the `elevation-stripe` modules use the color of the layer to draw
                a stripe pattern that changes width based on the surface of the terrain.

                '
            examples:
                stripes:
                    img: https://tangrams.github.io/tangram-sandbox/styles/elevation-stripes.png
                    url: https://tangrams.github.io/tangram-sandbox/styles/elevation-stripes.yaml
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        lighting: false
        mix:
        - functions-zoom
        - polygons-diagonal-stripes
        - patterns-stripes
        - space-tile
        raster: custom
        shaders:
            defines:
                NORMAL_TEXTURE_INDEX: 0
                STRIPES_ALPHA: 0.5
                STRIPES_DIR: vec3(-0.600,-0.420,0.600)
                STRIPES_PCT: 1.8
                STRIPES_SCALE: 20.0
                STRIPES_WIDTH: mix( (1.-zoom()), dot((sampleRaster(int(NORMAL_TEXTURE_INDEX)).rgb-.5)*2.,
                    STRIPES_DIR), zoom())*STRIPES_PCT
                ZOOM: linear
                ZOOM_END: 13.0
                ZOOM_IN: 0.0
                ZOOM_OUT: 1.0
                ZOOM_START: 0.0
    functions-aastep:
        doc:
            author:
                name: Matt DesLauriers
                twitter: mattdesl
            description: 'AnitAliased ```step()``` function implemented by [Matt DesLauriers](https://twitter.com/mattdesl)
                in this module <https://github.com/stackgl/glsl-aastep>

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "// AntiAliased Step function\n//=============================\n\
                    float aastep(float threshold, float value) {\n    #ifdef TANGRAM_FRAGMENT_SHADER\n\
                    \        #ifdef TANGRAM_EXTENSION_OES_standard_derivatives\n \
                    \           float afwidth = length(vec2(dFdx(value), dFdy(value)))\
                    \ * 0.70710678118654757;\n            return smoothstep(threshold-afwidth,\
                    \ threshold+afwidth, value);\n        #else\n            return\
                    \ step(threshold, value);\n        #endif  \n    #else\n     \
                    \   return step(threshold, value);\n    #endif\n}"
            extensions: OES_standard_derivatives
    functions-easing:
        doc:
            author:
                name: StackGL
                url: http://stack.gl/
            description: 'Easing functions originally develop by Robert Penner''s
                and transformed to GLSL by [StackGL](http://stack.gl/) in this repo:
                <https://github.com/stackgl/glsl-easings>

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "float linear (in float t) {\n    return t;\n}\n\nfloat exponentialIn\
                    \ (in float t) {\n    return t == 0.0 ? t : pow(2.0, 10.0 * (t\
                    \ - 1.0));\n}\n\nfloat exponentialOut (in float t) {\n    return\
                    \ t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialInOut\
                    \ (in float t) {\n    return t == 0.0 || t == 1.0\n    ? t\n \
                    \   : t < 0.5\n        ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\
                    \        : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat\
                    \ sineIn (in float t) {\n    return sin((t - 1.0) * HALF_PI) +\
                    \ 1.0;\n}\n\nfloat sineOut (in float t) {\n    return sin(t *\
                    \ HALF_PI);\n}\n\nfloat sineInOut (in float t) {\n    return -0.5\
                    \ * (cos(PI * t) - 1.0);\n}\n\nfloat qinticIn (in float t) {\n\
                    \    return pow(t, 5.0);\n}\n\nfloat qinticOut (in float t) {\n\
                    \    return 1.0 - (pow(t - 1.0, 5.0));\n}\n\nfloat qinticInOut\
                    \ (in float t) {\n    return t < 0.5\n        ? +16.0 * pow(t,\
                    \ 5.0)\n        : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\n\
                    float quarticIn (in float t) {\n    return pow(t, 4.0);\n}\n\n\
                    float quarticOut (in float t) {\n    return pow(t - 1.0, 3.0)\
                    \ * (1.0 - t) + 1.0;\n}\n\nfloat quarticInOut (in float t) {\n\
                    \    return t < 0.5\n        ? +8.0 * pow(t, 4.0)\n        : -8.0\
                    \ * pow(t - 1.0, 4.0) + 1.0;\n}\n\nfloat quadraticInOut (in float\
                    \ t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p\
                    \ + (4.0 * t) - 1.0;\n}\n\nfloat quadraticIn (in float t) {\n\
                    \    return t * t;\n}\n\nfloat quadraticOut (in float t) {\n \
                    \   return -t * (t - 2.0);\n}\n\nfloat cubicIn (in float t) {\n\
                    \    return t * t * t;\n}\n\nfloat cubicOut (in float t) {\n \
                    \   float f = t - 1.0;\n    return f * f * f + 1.0;\n}\n\nfloat\
                    \ cubicInOut (in float t) {\n    return t < 0.5\n        ? 4.0\
                    \ * t * t * t\n        : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n\
                    }\n\nfloat elasticIn (in float t) {\n    return sin(13.0 * t *\
                    \ HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat elasticOut\
                    \ (in float t) {\n    return sin(-13.0 * (t + 1.0) * HALF_PI)\
                    \ * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat elasticInOut (in float\
                    \ t) {\n    return t < 0.5\n        ? 0.5 * sin(+13.0 * HALF_PI\
                    \ * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5\
                    \ * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0,\
                    \ -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nfloat circularIn (in float\
                    \ t) {\n    return 1.0 - sqrt(1.0 - t * t);\n}\n\nfloat circularOut\
                    \ (in float t) {\n    return sqrt((2.0 - t) * t);\n}\n\nfloat\
                    \ circularInOut (in float t) {\n    return t < 0.5\n        ?\
                    \ 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n        : 0.5 * (sqrt((3.0\
                    \ - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat bounceOut\
                    \ (in float t) {\n    const float a = 4.0 / 11.0;\n    const float\
                    \ b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const\
                    \ float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n\
                    \    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t *\
                    \ t;\n\n    return t < a\n    ? 7.5625 * t2\n    : t < b\n   \
                    \     ? 9.075 * t2 - 9.9 * t + 3.4\n        : t < c\n        \
                    \    ? ca * t2 - cb * t + cc\n            : 10.8 * t * t - 20.52\
                    \ * t + 10.72;\n}\n\nfloat bounceIn (in float t) {\n    return\
                    \ 1.0 - bounceOut(1.0 - t);\n}\n\nfloat bounceInOut (in float\
                    \ t) {\n    return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 -\
                    \ t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n\
                    float backIn (in float t) {\n    return pow(t, 3.0) - t * sin(t\
                    \ * PI);\n}\n\nfloat backOut (in float t) {\n    float f = 1.0\
                    \ - t;\n    return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\
                    \nfloat backInOut (in float t) {\n    float f = t < 0.5\n    ?\
                    \ 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n    float g = pow(f,\
                    \ 3.0) - f * sin(f * PI);\n\n    return t < 0.5\n    ? 0.5 * g\n\
                    \    : 0.5 * (1.0 - g) + 0.5;\n}"
            defines:
                HALF_PI: 1.5707963267948966
                PI: 3.141592653589793
    functions-zoom:
        animated: true
        mix:
        - functions-easing
        shaders:
            blocks:
                global: "float zoom() {\n    return mix( ZOOM_IN, \n             \
                    \   ZOOM_OUT, \n                clamp(smoothstep(   ZOOM_START/ZOOM_MAX,\
                    \ \n                                    ZOOM_END/ZOOM_MAX, \n\
                    \                                    max(u_map_position.z/ZOOM_MAX,0.)*0.9),\
                    \ 0., 1.) );\n}"
            defines:
                ZOOM: linear
                ZOOM_END: 20.0
                ZOOM_IN: 0.0
                ZOOM_MAX: max(ZOOM_START, ZOOM_END)
                ZOOM_OUT: 1.0
                ZOOM_START: 14.0
    geometry-matrices:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: 'Useful set of functions to construct scale, rotation and
                translation of 2, 3 or 4 dimensions. For more information about matrices
                read [this chapter from The Book of Shaders](http://thebookofshaders.com/08/)

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "// Rotate in 2, 3 and 4 dimensions\n// ================================\n\
                    mat2 rotate2D (float angle) {\n    return mat2(cos(angle),-sin(angle),\n\
                    \                sin(angle),cos(angle));\n}\nmat3 rotateX3D (float\
                    \ phi) {\n    return mat3(\n        vec3(1.,0.,0.),\n        vec3(0.,cos(phi),-sin(phi)),\n\
                    \        vec3(0.,sin(phi),cos(phi)));\n}\nmat4 rotateX4D (float\
                    \ phi) {\n    return mat4(\n        vec4(1.,0.,0.,0),\n      \
                    \  vec4(0.,cos(phi),-sin(phi),0.),\n        vec4(0.,sin(phi),cos(phi),0.),\n\
                    \        vec4(0.,0.,0.,1.));\n}\nmat3 rotateY3D (float theta)\
                    \ {\n    return mat3(\n        vec3(cos(theta),0.,-sin(theta)),\n\
                    \        vec3(0.,1.,0.),\n        vec3(sin(theta),0.,cos(theta)));\n\
                    }\nmat4 rotateY4D (float theta) {\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n\
                    \        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n\
                    \        vec4(0.,0.,0.,1.));\n}\nmat3 rotateZ3D (float psi) {\n\
                    \    return mat3(\n        vec3(cos(psi),-sin(psi),0.),\n    \
                    \    vec3(sin(psi),cos(psi),0.),\n        vec3(0.,0.,1.));\n}\n\
                    mat4 rotateZ4D (float psi) {\n    return mat4(\n        vec4(cos(psi),-sin(psi),0.,0),\n\
                    \        vec4(sin(psi),cos(psi),0.,0.),\n        vec4(0.,0.,1.,0.),\n\
                    \        vec4(0.,0.,0.,1.));\n}\n//\n// Scale 4 dimensions\n//\
                    \ ================================\nmat4 scale4D (float x, float\
                    \ y, float z) {\n    return mat4(\n        vec4(x,   0.0, 0.0,\
                    \ 0.0),\n        vec4(0.0, y,   0.0, 0.0),\n        vec4(0.0,\
                    \ 0.0, z,   0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n\
                    }\n//\n// Translate in 4 dimensions\nmat4 translate4D (float x,\
                    \ float y, float z) {\n    return mat4(\n        vec4(1.0, 0.0,\
                    \ 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0,\
                    \ 0.0, 1.0, 0.0),\n        vec4(x,   y,   z,   1.0)\n    );\n}"
            defines:
                HALF_PI: 1.5707963267948966
                PI: 3.141592653589793
                TWO_PI: 6.283185307179586
    patterns-stripes:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: "Collection of functions to draw stripes. To learn more about\
                \ patterns check [this chapter from the Book of Shaders](https://thebookofshaders.com/09/)\
                \    \n"
            examples:
                grain-area:
                    img: https://tangrams.github.io/tangram-sandbox/styles/grain-area.png
                    lines: 26
                    url: https://tangrams.github.io/tangram-sandbox/styles/grain-area.yaml
                press:
                    img: https://tangrams.github.io/tangram-sandbox/styles/press.png
                    lines: 150
                    url: https://tangrams.github.io/tangram-sandbox/styles/press.yaml
                radar:
                    img: https://tangrams.github.io/tangram-sandbox/styles/radar.png
                    url: https://tangrams.github.io/tangram-sandbox/styles/radar.yaml
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        mix:
        - functions-aastep
        - geometry-matrices
        shaders:
            blocks:
                global: "// Return a distance function of stripes\nfloat stripesDF\
                    \ (vec2 st) {\n    return abs(sin(st.y*PI));\n}\n\n// Adjustable\
                    \ width stripes\nfloat stripes (vec2 st, float width) {\n    return\
                    \ aastep(width, stripesDF(st));\n}\n\n// Adjustable Angle\nfloat\
                    \ stripes (vec2 st, float width, float angle) {\n    st = rotate2D(angle)\
                    \ * st;\n    return stripes(st, width);\n}\n\n// Faster optimisation\
                    \ of diagonal stripes\nfloat diagonalStripes (vec2 st) {\n   \
                    \ vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    if (mod(i_st.y,2.)\
                    \ - mod(i_st.x,2.) == 0.) {\n        return 1.0 - aastep(f_st.x,f_st.y);\n\
                    \    } else {\n        return aastep(f_st.x,f_st.y);\n    }\n\
                    }\n\n// Faster optimisation of diagonal stripes with controlable\
                    \ width\nfloat diagonalStripes (vec2 st, float width) {\n    st.y\
                    \ -= st.x;\n    return stripes(st, width);\n}"
            defines:
                PI: 3.141592653589793
    polygons-diagonal-stripes:
        base: polygons
        mix:
        - patterns-stripes
        - space-tile
        shaders:
            blocks:
                color: "color.a = diagonalStripes(  (getTileCoords()*0.999)*floor(STRIPES_SCALE),\
                    \ \n                            STRIPES_WIDTH) * STRIPES_ALPHA;"
            defines:
                STRIPES_ALPHA: 0.5
                STRIPES_SCALE: 2.0
                STRIPES_WIDTH: 0.5
    space-tile:
        doc:
            author:
                name: Patricio Gonzalez Vivo
                twitter: patriciogv
            description: 'Get the position on the tile

                '
            licence: MIT
            tangram-version: 0.0.7
            version: 0.0.1
        shaders:
            blocks:
                global: "// Variant to be add to both vertex and fragments shaders\n\
                    varying vec3 v_pos;\n//\n// Get the coordinates in tile space\n\
                    // ================================\nvec2 getTileCoords() {\n\
                    \    return fract(v_pos.xy);\n}\n"
                position: '// Normalize the attribute position of a vertex

                    v_pos = modelPosition().xyz;'
